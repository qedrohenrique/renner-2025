# -*- coding: utf-8 -*-
"""grafo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1se2oeahqClAy8Z9UHq9BTsysfj-QRUdy

### Inputs:
  - Número de corredores
  - Número de andares
  - Excel - Produtos nos corredores

### Outputs
  - Grafo representativo
  - Área de picking (caminho percorrido no grafo)

1. Ordenar a caixa
2. Procurar o produto com maior número de peças na caixa (A)
3. Ir para o corredor com maior número de peças daquele produto (A)
4. Se não completar o produto na caixa, procurar o corredor mais próximo que tenha qualquer quantidade de peças daquele produto (A)
5. Procurar pelo produto com segundo maior número de peças (B)
6. Ir para o corredor mais próximo com aquele produto (B)
7. Procurar o corredor mais próximo até completar a caixa com o produto (B)
8. Repetir 5, 6 e 7 para os demais produtos

1. Pegar uma caixa aleatória
2. Analisar N caixas para ver qual é aquela com maior área de picking em comum com a área de picking da onda.
3. Atualizar a área de picking da onda
4. Repetir até não poder mais (classe de onda diferente ou máximo de peças na onda)
"""

# Importar Excel

from google.colab import drive
import pandas as pd

drive.mount('/content/drive')

#
# Pega as sheets do excel e transforma em variaveis
#

excel_file_path = '/content/drive/My Drive/Mathsol/data.xlsx'
xls = pd.ExcelFile(excel_file_path)

sheets_names = xls.sheet_names
caixas_excel = pd.read_excel(excel_file_path, sheet_name='Caixas')
estoque = pd.read_excel(excel_file_path, sheet_name='Estoque')

# Conta numero de ondas do excel

len(caixas_excel['ONDA_ID'].unique())

# Gerar inputs e definir vértice

andares = estoque.ANDAR.unique()
num_corredores = estoque.CORREDOR.max()
estoque = estoque

# Classes representacional de um vértice

class Vertice:
  def __init__(self, andar, corredor, posicao_centro, produtos = dict()):
    self.andar = andar
    self.corredor = corredor
    self.posicao_centro = posicao_centro
    self.produtos = produtos
    self.caixas = []

  def __eq__(self, other):
      if isinstance(other, Vertice):
          return (self.andar == other.andar and
                  self.corredor == other.corredor and
                  self.posicao_centro == other.posicao_centro)
      return False

  def __hash__(self):
      return hash((self.andar, self.corredor, self.posicao_centro))

  def __repr__(self):
      return f"Vertice(andar={self.andar}, corredor={self.corredor}, posicao_centro={self.posicao_centro})"

  def insert_product(self, product, quantity):
    self.produtos[product] = quantity

  def insert_caixas(self, caixa):
    self.caixas.append(caixa)

  def remove_product(self, product, quantity):
    self.produtos[product] -= quantity
    if self.produtos[product] < 0:
      raise Exception("Quantidade não pode ser negativa")

# Funções auxiliares para vértices

def get_vertex(G, andar, corredor):
  for v in G.nodes():
    if v.andar == andar and v.corredor == corredor:
      return v
  return None

def get_vertex_complete(G, andar, corredor, pos_centro):
  for v in G.nodes():
    if v.andar == andar and v.corredor == corredor and v.posicao_centro == pos_centro:
      return v
  return None

def get_label(v: Vertice):
  return "(" + str(v.andar) + ", " + str(v.corredor) + ", " + str(v.posicao_centro) + ")"


def get_pos(v: Vertice, peso = 1):
  x = v.posicao_centro + (v.andar * num_corredores // 2)
  y = 0

  if v.corredor % 2 == 1:
    y = 1

  if v.corredor % 2 == 0:
    y = -1

  if v.corredor == 0:
    y = 0

  return (x * peso, y)


def get_color(v: Vertice):
  if v.andar == 0 and v.corredor == 0 and v.posicao_centro == 0:
      return 'green'  # Cor para o vértice inicial
  if v.posicao_centro == 1 and v.corredor == 0:
      return 'red'  # Cor para vértices centrais
  if v.corredor == 0:
    return 'yellow'  # Cor para vértices do corredor central
  else:
      return 'blue'  # Cor para os demais vértices

# Gerar dicionário a partir do excel

from collections import defaultdict

produtos_dict = defaultdict(lambda: defaultdict(lambda: defaultdict(int)))

def defaultdict_to_dict(d):
    if isinstance(d, defaultdict):
        return {k: defaultdict_to_dict(v) for k, v in d.items()}
    elif isinstance(d, dict):
        return {k: defaultdict_to_dict(v) for k, v in d.items()}
    else:
        return d

def excel_data_to_nodes():
    for index, row in estoque.iterrows():
        produtos_dict[row['ANDAR']][row['CORREDOR']][row['SKU']] = row['PECAS']

    return produtos_dict

produtos = excel_data_to_nodes()

# Gerar grafo

import networkx as nx
import matplotlib.pyplot as plt

G = nx.Graph()

def generate_vertices():
  G.add_node(Vertice(0, 0, 0)) # Vértice inicial

  for andar in andares:
    pos_centro = 1

    for corredor in range(1, num_corredores + 1):
      G.add_node(Vertice(andar, corredor, pos_centro, produtos[andar][corredor])) # Vértice do corredor

      if(corredor % 2 == 0):
        G.add_node(Vertice(andar, 0, pos_centro)) # Vértice entre 2 corredores
        pos_centro += 1


def generate_edges():
  for node in G.nodes():
    for other_node in G.nodes():

      # Ligações envolvem sempre um vértice do corredor central
      if node.corredor != 0:
        continue

      # Interliga andares
      if node.andar + 1 == other_node.andar and node.posicao_centro == num_corredores // 2 and other_node.posicao_centro == 1 and other_node.corredor == 0:
        G.add_edge(node, other_node, weight=10)

      # Interliga o corredor central do mesmo andar
      if node.andar == other_node.andar and other_node.corredor == 0 and node.posicao_centro + 1 == other_node.posicao_centro:
        G.add_edge(node, other_node, weight=1)

      # Interliga corredor com seu centro
      if node.andar == other_node.andar and node.posicao_centro == other_node.posicao_centro and node.corredor != other_node.corredor:
        G.add_edge(node, other_node, weight=1)

# Plotar grafico

generate_vertices()
generate_edges()

# Gerar cores para os nós
node_colors = []
node_labels = {}
node_positions = {}

for v in G.nodes():
  node_colors.append(get_color(v))
  node_labels[v] = get_label(v)
  node_positions[v] = get_pos(v, 50)

# Desenhar o grafo
nx.draw(G, pos=node_positions, with_labels=False, labels=node_labels, node_color=node_colors, node_size=5)
plt.figure(figsize=(24,24))
plt.show()

# Funções auxiliares para estoque e grafo

def ordenar_caixa_por_valor(caixa):
    return sorted(caixa, key=lambda item: list(item.values())[0], reverse=True)

def encontrar_maior_pecas_por_sku(dataframe, sku):
    filtro_sku = dataframe[dataframe['SKU'] == sku]

    if filtro_sku.empty:
        raise Exception("SKU não encontrado")

    linha_maior_pecas = filtro_sku.loc[filtro_sku['PECAS'].idxmax()]

    if linha_maior_pecas['PECAS'] == 0:
      raise Exception("SKU sem peças")

    return linha_maior_pecas['ANDAR'], linha_maior_pecas['CORREDOR'], linha_maior_pecas['PECAS']

def get_min_distance(dataframe, andar, corredor, sku):
  min = 999999999
  min_row = None

  df = dataframe
  same_corridor = df[(df['ANDAR'] == andar) & (df['CORREDOR'] == corredor) & (df['SKU'] == sku) & (df['PECAS'] > 0)]
  if not same_corridor.empty:
    return same_corridor.iloc[0]

  for idx, row in dataframe.iterrows():
    distance = abs(corredor - row['CORREDOR'])
    if(distance < min and distance != 0 and row['ANDAR'] == andar):
      min = distance
      min_row = row

  return min_row

# TODO: Avalizar se a posicao do corredor deve ser levado em conta neste cálculo
def get_nearest_floor(dataframe, andar):
  min = 999999999
  min_row = None
  for idx, row in dataframe.iterrows():
    distance = abs(andar - row['ANDAR'])
    if(distance < min and distance != 0):
      min = distance
      min_row = row

  return min_row['ANDAR']

# Procura no mesmo andar
# Procura nos andares de baixo e de cima
def encontrar_corredor_mais_proximo(dataframe, sku, andar, corredor):
  filtro_sku = dataframe[(dataframe['SKU'] == sku) & (dataframe['PECAS'] != 0)]

  if filtro_sku.empty:
      raise Exception("SKU não encontrado")

  if (filtro_sku['ANDAR'] == andar).any():
    min_row = get_min_distance(filtro_sku, andar, corredor, sku)
    return min_row['ANDAR'], min_row['CORREDOR'], min_row['PECAS']

  closest_floor = get_nearest_floor(filtro_sku, andar)
  if andar < closest_floor:
    min_row = get_min_distance(filtro_sku, closest_floor, filtro_sku.loc[filtro_sku['ANDAR'] == closest_floor, 'CORREDOR'].min() + 1, sku)
    return min_row['ANDAR'], min_row['CORREDOR'], min_row['PECAS']

  if andar > closest_floor:
    min_row = get_min_distance(filtro_sku, closest_floor, filtro_sku.loc[filtro_sku['ANDAR'] == closest_floor, 'CORREDOR'].max() + 1, sku)
    return min_row['ANDAR'], min_row['CORREDOR'], min_row['PECAS']

  raise Exception("Estoque vazio")


def sku_from_dict(produto):
  return next(iter(produto.keys()))

def quantity_from_dict(produto):
  return next(iter(produto.values()))

def remover_sku_do_estoque(estoque, andar, corredor, sku, nova_quantidade):
  estoque.loc[(estoque['ANDAR'] == andar) & (estoque['CORREDOR'] == corredor) & (estoque['SKU'] == sku), 'PECAS'] = nova_quantidade

def total_pecas(caixa):
  total = 0
  for produto in caixa:
    total += quantity_from_dict(produto)
  return total

sheets_names = xls.sheet_names
estoque = pd.read_excel(excel_file_path, sheet_name='Estoque')

caixas = []
caixas_id = []
classe_ondas = []
for caixa_id, group in caixas_excel.groupby('CAIXA_ID'):

    box_list = []
    for index, row in group.iterrows():
      box_list.append({row['SKU']: row['PECAS']})
      classe = row['CLASSE_ONDA']
    caixas_id.append(caixa_id)
    classe_ondas.append(classe)
    caixas.append(box_list)

# Algoritmo completo de preenchimento de caixas
import plotly.graph_objects as go

should_print_path = False
plot_graph = False
caixas_e_caminho = []

for caixa, id, classe in zip(caixas, caixas_id, classe_ondas):
  print()
  print(f"Analisando a caixa {id}")

  caixa_ordenada = ordenar_caixa_por_valor(caixa)
  start = get_vertex(G, 0, 0)

  walked_vertexes = []
  walked_edges = []

  produto = caixa_ordenada[0]
  sku = sku_from_dict(produto)
  quantity = quantity_from_dict(produto)
  total_pecas_caixa = total_pecas(caixa)

  print("Procurando por: ", sku, "-", quantity) if should_print_path else None

  # PRIMEIRA PRODUTO
  # Busca pelo estoque
  andar, corredor, pecas = encontrar_maior_pecas_por_sku(estoque, sku)
  target = get_vertex(G, andar, corredor)
  menor_caminho = nx.shortest_path(G, source=start, target=target, weight='weight')
  arestas_caminho = [(menor_caminho[i], menor_caminho[i+1]) for i in range(len(menor_caminho) - 1)]
  print(f"Encontradas {pecas} em {andar} - {corredor}") if should_print_path else None
  print(f"O menor caminho entre {start} e {target} é: {menor_caminho}") if should_print_path else None

  # Atualização da quantidade de peças no armazem e de peças restantes para preencher a caixa
  nova_quantidade_corredor = 0 if pecas < quantity_from_dict(produto) else pecas - quantity_from_dict(produto)
  remover_sku_do_estoque(estoque, andar, corredor, sku_from_dict(produto), nova_quantidade_corredor)
  produto[sku_from_dict(produto)] -= min(pecas, quantity_from_dict(produto))
  quantity = quantity_from_dict(produto)
  print(f"Faltam {produto[sku_from_dict(produto)]} para preencher a caixa. No corredor agora tem {nova_quantidade_corredor}") if should_print_path else None
  if(quantity_from_dict(produto) == 0):
    caixa_ordenada.pop(0)

  # Salva o caminho percorrido, e prepara variáveis para repetição do loop se necessário
    walked_vertexes.extend(menor_caminho)
    walked_edges.extend(arestas_caminho)
    start = target

  #
  # Demais iterações
  #

  while(quantity != 0):
    print("Procurando por: ", sku, "-", quantity) if should_print_path else None

    # Busca pelo estoque
    andar, corredor, pecas = encontrar_corredor_mais_proximo(estoque, sku_from_dict(produto), start.andar, start.corredor)
    target = get_vertex(G, andar, corredor)
    menor_caminho = nx.shortest_path(G, source=start, target=target, weight='weight')
    arestas_caminho = [(menor_caminho[i], menor_caminho[i+1]) for i in range(len(menor_caminho) - 1)]
    print(f"Encontradas {pecas} em {andar} - {corredor}") if should_print_path else None
    print(f"O menor caminho entre {start} e {target} é: {menor_caminho}") if should_print_path else None

    # Atualização da quantidade de peças no armazem e de peças restantes para preencher a caixa
    nova_quantidade_corredor = 0 if pecas < quantity_from_dict(produto) else pecas - quantity_from_dict(produto)
    remover_sku_do_estoque(estoque, andar, corredor, sku_from_dict(produto), nova_quantidade_corredor)
    produto[sku_from_dict(produto)] -= min(pecas, quantity_from_dict(produto))
    quantity = quantity_from_dict(produto)
    print(f"Faltam {produto[sku_from_dict(produto)]} para preencher a caixa. No corredor agora tem {nova_quantidade_corredor}") if should_print_path else None
    if(quantity_from_dict(produto) == 0):
      caixa_ordenada.pop(0)

    # Salva o caminho percorrido, e prepara variáveis para repetição do loop se necessário
    walked_vertexes.extend(menor_caminho)
    walked_edges.extend(arestas_caminho)
    start = target

    # Percorrer estoque para demais produtos na caixa

  while(len(caixa_ordenada) != 0):
    produto = caixa_ordenada[0]

    print(f"\nProcurando por: ", sku_from_dict(produto), "-", quantity_from_dict(produto)) if should_print_path else None

    # Busca pelo estoque
    andar, corredor, pecas = encontrar_corredor_mais_proximo(estoque, sku_from_dict(produto), start.andar, start.corredor)
    target = get_vertex(G, andar, corredor)
    menor_caminho = nx.shortest_path(G, source=start, target=target, weight='weight')
    arestas_caminho = [(menor_caminho[i], menor_caminho[i+1]) for i in range(len(menor_caminho) - 1)]
    print(f"Encontradas {pecas} em {andar} - {corredor}") if should_print_path else None
    print(f"O menor caminho entre {start} e {target} é: {menor_caminho}") if should_print_path else None

    # Atualização da quantidade de peças no armazem e de peças restantes para preencher a caixa
    nova_quantidade_corredor = 0 if pecas < quantity_from_dict(produto) else pecas - quantity_from_dict(produto)
    remover_sku_do_estoque(estoque, andar, corredor, sku_from_dict(produto), nova_quantidade_corredor)
    produto[sku_from_dict(produto)] -= min(pecas, quantity_from_dict(produto))
    print(f"Faltam {produto[sku_from_dict(produto)]} para preencher a caixa. No corredor agora tem {nova_quantidade_corredor}") if should_print_path else None
    if(quantity_from_dict(produto) == 0):
      caixa_ordenada.pop(0)

    # Salva o caminho percorrido, e prepara variáveis para repetição do loop se necessário
    walked_vertexes.extend(menor_caminho)
    walked_edges.extend(arestas_caminho)
    start = target

  walked_corridors = []
  for v in walked_vertexes:
    if v.corredor != 0:
      walked_corridors.append(v)

  caixas_e_caminho.append({
      'id': id,
      'walked_vertexes': walked_vertexes,
      'walked_edges': walked_edges,
      'walked_corridors': walked_corridors,
      'pecas': total_pecas_caixa,
      'classe': classe
  })

  target.insert_caixas({
      'id': id,
      'walked_vertexes': walked_vertexes,
      'walked_edges': walked_edges,
      'walked_corridors': walked_corridors,
      'pecas': total_pecas_caixa,
      'classe': classe
  })

  if plot_graph:
    # Criação de estrutura de dados para plotagem do gráfico
    vertices_navegados = set(walked_vertexes)
    arestas_navegadas = set(walked_edges)
    node_colors_navegados = []
    edge_colors_navegados = []

    for v in G.nodes():
      node_colors_navegados.append('green' if v in vertices_navegados else get_color(v))

    for e in G.edges():
      edge_colors_navegados.append('green' if (e[0],e[1]) in arestas_navegadas or (e[1], e[0]) in arestas_navegadas else 'black')

    # Criar listas de coordenadas dos nós
    x_nodes = [node_positions[node][0] for node in G.nodes()]
    y_nodes = [node_positions[node][1] for node in G.nodes()]

    # Criar traços para as arestas com cores individuais
    edge_traces = []
    for edge, color in zip(G.edges(), edge_colors_navegados):
        x0, y0 = node_positions[edge[0]]
        x1, y1 = node_positions[edge[1]]
        edge_trace = go.Scatter(
            x=[x0, x1, None],
            y=[y0, y1, None],
            line=dict(width=5, color=color),  # Cor personalizada para cada aresta
            hoverinfo='none',
            mode='lines'
        )
        edge_traces.append(edge_trace)

    # Traçar os nós
    node_trace = go.Scatter(
        x=x_nodes,
        y=y_nodes,
        mode='markers',
        hoverinfo='text',
        marker=dict(
            size=12,
            color=node_colors_navegados,  # Adiciona a cor dos nós
        )
    )

    # Adicionar os rótulos (se houver)
    node_text = [node_labels[node] if node in node_labels else str(node) for node in G.nodes()]
    node_trace.text = node_text

    # Criar a figura com todas as arestas e nós
    fig = go.Figure()

    # Adicionar todas as arestas
    for edge_trace in edge_traces:
        fig.add_trace(edge_trace)

    # Adicionar os nós
    fig.add_trace(node_trace)

    # Ajustar o layout
    fig.update_layout(
        showlegend=False,
        hovermode='closest',
        margin=dict(b=0, l=0, r=0, t=0),
        xaxis=dict(showgrid=False, zeroline=False),
        yaxis=dict(showgrid=False, zeroline=False)
    )

    # Mostrar o gráfico interativo
    fig.show()

# Funcao auxiliar para encontrar caixas com maior sobreposicao
def lista_mais_comum(lista_vertices, outras_caixas, onda_caixas, classe_onda):
    max_comum = -1
    inter_num = -1
    melhor_lista = None

    iter_caixas = outras_caixas

    if len(outras_caixas) > 30:
      iter_caixas = outras_caixas[0:30]

    for sublista in iter_caixas:
        comum = len(set(lista_vertices) & set(sublista['walked_vertexes']))
        if comum > max_comum and (not(sublista['id'] in onda_caixas)) and classe_onda == sublista['classe']:
            max_comum = comum
            melhor_lista = sublista
            inter_num = comum

    return melhor_lista, inter_num

def remove_item_from_list(lista, id):
  return [item for item in lista if item["id"] != id]

def get_boxes_within_onda(vertices):
  box = []
  for v in vertices:
    box.extend(v.caixas)
  return box

# Configurar colab para conseguir rodar o algoritmo
import sys
print(sys.getrecursionlimit())
sys.setrecursionlimit(3000)

# Algoritmo de formacao de ondas

import copy
ondas = []
onda_caixas = []
onda_idx = 0

print('Copiando lista')
caixas_e_caminho_copy = copy.deepcopy(caixas_e_caminho)
caixas_e_caminho_copy.sort(key=lambda x: len(x['walked_corridors']), reverse=True)
print('Cópia pronta')

while len(caixas_e_caminho_copy) != 0:
  onda_vertexes = []
  onda_quantity = 0
  onda_idx += 1
  caixa_atual = caixas_e_caminho_copy.pop(0)
  classe_onda = caixa_atual['classe']
  ondas_caixas_e_classe = []

  if onda_quantity + caixa_atual['pecas'] > 6000:
    raise Exception("Capacidade máxima de onda excedida na primeira caixa")
  else:
    print(f"Adicionado a caixa {caixa_atual['id']} a onda {onda_idx}")
    onda_vertexes.extend(caixa_atual['walked_vertexes'])
    onda_quantity += caixa_atual['pecas']
    caixas_e_caminho_copy = remove_item_from_list(caixas_e_caminho_copy, caixa_atual['id'])
    onda_caixas.append(caixa_atual['id'])
    ondas_caixas_e_classe.append({'id': caixa_atual['id'], 'classe': caixa_atual['classe']})

    while True:
      boxes_within_onda = get_boxes_within_onda(onda_vertexes)
      caixa_atual, inter_num = lista_mais_comum(onda_vertexes, boxes_within_onda, onda_caixas, classe_onda)

      if caixa_atual == None:
        if len(caixas_e_caminho_copy) != 0:
          i = 0
          while i < len(caixas_e_caminho_copy):
            if(caixas_e_caminho_copy[i]['classe'] == classe_onda):
              caixa_atual = caixas_e_caminho_copy.pop(i)
              break
            i += 1
        else:
          caixa_atual = {}

      if len(caixas_e_caminho_copy) == 0:
        print("Caixas todas alocadas antes do limite da onda.")
        ondas.append({
            'id': onda_idx,
            'vertexes': onda_vertexes,
            'quantity': onda_quantity,
            'boxes': ondas_caixas_e_classe
        })
        break
      if len(caixas_e_caminho_copy) != 0 and caixa_atual == None:
        print(f"Sem mais caixas da classe de onda {classe_onda}. Fechando a onda.")
        ondas.append({
            'id': onda_idx,
            'vertexes': onda_vertexes,
            'quantity': onda_quantity,
            'boxes': ondas_caixas_e_classe
        })
        break
      if onda_quantity + caixa_atual['pecas'] > 6000:
        print("Capacidade máxima de onda excedida.")
        ondas.append({
            'id': onda_idx,
            'vertexes': onda_vertexes,
            'quantity': onda_quantity,
            'boxes': ondas_caixas_e_classe
        })
        break
      else:
        print(f"Adicionado a caixa {caixa_atual['id']} a onda {onda_idx} - Adicionado {caixa_atual['pecas']} - Total {onda_quantity}")
        onda_vertexes.extend(caixa_atual['walked_vertexes'])
        onda_quantity += caixa_atual['pecas']
        caixas_e_caminho_copy = remove_item_from_list(caixas_e_caminho_copy, caixa_atual['id'])
        onda_caixas.append(caixa_atual['id'])
        ondas_caixas_e_classe.append({'id': caixa_atual['id'], 'classe': caixa_atual['classe']})

def get_max_and_min_corridors(vertexes):
  data = []
  for andar in andares:
    max_corridor_even = None
    min_corridor_even = None
    max_corridor_odd = None
    min_corridor_odd = None
    for v in vertexes:
      if v.andar == andar:
        if v.corredor % 2 == 0:
          if max_corridor_even == None or max_corridor_even < v.corredor:
            max_corridor_even = v.corredor
          if min_corridor_even == None or min_corridor_even > v.corredor:
            min_corridor_even = v.corredor
        else:
          if max_corridor_odd == None or max_corridor_odd < v.corredor:
            max_corridor_odd = v.corredor
          if min_corridor_odd == None or min_corridor_odd > v.corredor:
            min_corridor_odd = v.corredor

    data.append({
      'andar': andar,
      'max_corridor_even': max_corridor_even,
      'min_corridor_even': min_corridor_even,
      'max_corridor_odd': max_corridor_odd,
      'min_corridor_odd': min_corridor_odd
    })

  return data

for onda in ondas:
  data = get_max_and_min_corridors(onda['vertexes'])

  for d in data:
    picking = d['max_corridor_even'] - d['min_corridor_even'] if d['max_corridor_even'] != None else 0
    picking += d['max_corridor_odd'] - d['min_corridor_odd'] if d['max_corridor_odd'] != None else 0
    print(f"Andar {d['andar']}: {picking}", end=' ')
  print()

for onda in ondas:
  data = get_max_and_min_corridors(onda['vertexes'])
  print(data)

def plot_graph(walked_edges, walked_vertexes):
  vertices_navegados = set(walked_vertexes)
  arestas_navegadas = set(walked_edges)
  node_colors_navegados = []
  edge_colors_navegados = []

  for v in G.nodes():
    node_colors_navegados.append('green' if v in vertices_navegados else get_color(v))

  for e in G.edges():
    edge_colors_navegados.append('green' if (e[0],e[1]) in arestas_navegadas or (e[1], e[0]) in arestas_navegadas else 'black')

  # Criar listas de coordenadas dos nós
  x_nodes = [node_positions[node][0] for node in G.nodes()]
  y_nodes = [node_positions[node][1] for node in G.nodes()]

  # Criar traços para as arestas com cores individuais
  edge_traces = []
  for edge, color in zip(G.edges(), edge_colors_navegados):
      x0, y0 = node_positions[edge[0]]
      x1, y1 = node_positions[edge[1]]
      edge_trace = go.Scatter(
          x=[x0, x1, None],
          y=[y0, y1, None],
          line=dict(width=5, color=color),  # Cor personalizada para cada aresta
          hoverinfo='none',
          mode='lines'
      )
      edge_traces.append(edge_trace)

  # Traçar os nós
  node_trace = go.Scatter(
      x=x_nodes,
      y=y_nodes,
      mode='markers',
      hoverinfo='text',
      marker=dict(
          size=12,
          color=node_colors_navegados,  # Adiciona a cor dos nós
      )
  )

  # Adicionar os rótulos (se houver)
  node_text = [node_labels[node] if node in node_labels else str(node) for node in G.nodes()]
  node_trace.text = node_text

  # Criar a figura com todas as arestas e nós
  fig = go.Figure()

  # Adicionar todas as arestas
  for edge_trace in edge_traces:
      fig.add_trace(edge_trace)

  # Adicionar os nós
  fig.add_trace(node_trace)

  # Ajustar o layout
  fig.update_layout(
      showlegend=False,
      hovermode='closest',
      margin=dict(b=0, l=0, r=0, t=0),
      xaxis=dict(showgrid=False, zeroline=False),
      yaxis=dict(showgrid=False, zeroline=False)
  )

  # Mostrar o gráfico interativo
  fig.show()

for onda in ondas:
  data = get_max_and_min_corridors(onda['vertexes'])
  walked_edges = []
  walked_vertexes = []

  for d in data:
    if(d['min_corridor_even'] != None and d['max_corridor_even'] != None):
      for i in range(d['min_corridor_even'], d['max_corridor_even'] + 1, 2):
        walked_vertexes.append(get_vertex(G, d['andar'], i))
        walked_vertexes.append(get_vertex_complete(G, d['andar'], 0, i//2))
        walked_edges.append((get_vertex_complete(G, d['andar'], 0, i//2), get_vertex(G, d['andar'], i)))
    else:
      print("Skipping even")

    if(d['min_corridor_odd'] and d['max_corridor_odd']):
      for i in range(d['min_corridor_odd'], d['max_corridor_odd'] + 1, 2):
        walked_vertexes.append(get_vertex(G, d['andar'], i))
        walked_vertexes.append(get_vertex_complete(G, d['andar'], 0, (i+1)//2))
        walked_edges.append((get_vertex_complete(G, d['andar'], 0, (i+1)//2), get_vertex(G, d['andar'], i)))
    else:
      print("Skipping odd")



  plot_graph(walked_edges, walked_vertexes)